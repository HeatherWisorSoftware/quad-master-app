@page "/QuadsPage/{TournamentId:int}"
@using Microsoft.EntityFrameworkCore
@using QuadMasterApp.Services
@inject NavigationManager NavigationManager
@inject TournamentContext DbContext
@inject IThemeProvider ThemeProvider
@inject AppStateService AppState


<HeadContent>
    <link href="print-styles.css" rel="stylesheet" media="print" />
</HeadContent>

<h1>Tournament Quads: @ViewModel?.TournamentName</h1>

<div class="d-flex flex-wrap justify-content-between mb-4">
    <!-- MudBlazor Pagination Controls -->
    <div class="pagination-controls d-flex align-items-center">
        <MudPagination Variant="Variant.Outlined"
                       Count="@TotalPages"
                       SelectedChanged="OnPageChanged"
                       Selected="@CurrentPage"
                       Color="Color.Primary"
                       Size="Size.Medium"
                       Class="my-2" />

        <MudText Typo="Typo.body2" Class="ml-4">
            Group @CurrentPage of @TotalPages | Total Quads: @(ViewModel?.AllQuads?.Count ?? 0)
        </MudText>
    </div>

    <div>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="GenerateQuads"
                   Disabled="@(!ViewModel.AllowQuadGeneration)">
            Generate Quads
        </MudButton>

        <MudButton Variant="Variant.Outlined"
                   Color="Color.Secondary"
                   OnClick="PrintPage"
                   StartIcon="@Icons.Material.Filled.Print"
                   Class="ml-2">
            Print Tournament
        </MudButton>

    </div>
</div>

<div class="quad-container">
    <MudDropContainer T="TournamentPlayer"
                      Items="@ViewModel.UnassignedPlayers"
                      ItemDropped="PlayerAssigned"
                      Class="d-flex flex-column flex-grow-1">

        <ChildContent>
            <div class="d-flex">
                <div class="quads-section">
                    <div class="d-flex flex-wrap">
                        @for (var i = 0; i < DisplayedQuads.Count; i++)
                        {
                            var quad = DisplayedQuads[i];
                            var quadId = quad.Id.ToString();
                            var quadColorClass = GetThemeColorClass(quad.Id);
                            <MudPaper Class="@($"quad-paper ma-2 {quadColorClass}")" Elevation="3">
                                <div class="quad-table">
                                    <div class="quad-side">
                                        <div class="quad-identifier">
                                            <span>@quad.Title</span>
                                        </div>
                                    </div>
                                    <div class="quad-main">
                                        <div class="quad-header">
                                            <div class="quad-header-cell player-header">Player</div>
                                            <div class="quad-header-cell">Rd 1</div>
                                            <div class="quad-header-cell">Rd 2</div>
                                            <div class="quad-header-cell">Rd 3</div>
                                            <div class="quad-header-cell">Total</div>
                                        </div>

                                        <!-- For quad players -->
                                        <MudDropZone T="TournamentPlayer"
                                                     Identifier="@quadId"
                                                     ItemsSelector="@(p => p.QuadId?.ToString() == quadId)"
                                                     AllowReorder="true"
                                                     Class="quad-dropzone" />
                                    </div>
                                </div>
                            </MudPaper>
                        }
                    </div>
                </div>

                <MudPaper Class="unassigned-paper ma-2" Elevation="2">
                    <div class="unassigned-header">
                        <h3 class="text-center">Unassigned Players</h3>
                    </div>
                    <MudDropZone T="TournamentPlayer"
                                 Identifier="unassigned"
                                 ItemsSelector="@(p => p.QuadId == null)"
                                 AllowReorder="true"
                                 Class="unassigned-dropzone" />
                </MudPaper>
            </div>
        </ChildContent>

        <ItemRenderer>
            @if (context.QuadId.HasValue)
            {
                <div class="quad-player-row">
                    <div class="player-cell">
                        <div class="player-position">@GetPlayerPositionInQuad(context)</div>
                        <div class="player-name">@context.Player.LastName @context.Player.FirstName</div>
                        <div class="player-rating">@context.Player.Ranking</div>
                    </div>

                    @{
                        var opponents = GetQuadOpponents(context);
                    }

                    @foreach (var round in new[] { 1, 2, 3 })
                    {
                        <div class="round-cell">
                            <div class="opponent">@opponents[round - 1]</div>
                            <div class="score-cell">
                                <MudTextField T="string"
                                              Class="score-input"
                                              Value="@GetScore(context, round)"
                                              ValueChanged="@(async (string value) => await SaveScore(context, round, value))"
                                              Immediate="true"
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Disabled="false" />
                            </div>
                            <div class="table-number">TBL @GetTableNumber(context, round)</div>
                        </div>
                    }

                    <div class="total-cell">
                        <span class="total-score">@GetTotalScore(context)</span>
                        @if (ViewModel.AllowPlayerRemoval)
                        {
                            <MudIconButton Icon="@Icons.Material.Filled.Close"
                                           Size="Size.Small"
                                           Class="remove-btn"
                                           OnClick="@(() => RemovePlayerFromQuad(context))" />
                        }
                    </div>
                </div>
            }
            else
            {
                <div class="player-card unassigned">
                    <div class="player-info">
                        <div class="player-name">@context.Player.LastName @context.Player.FirstName</div>
                        <div class="player-rating">@context.Player.Ranking</div>
                    </div>
                </div>
            }
        </ItemRenderer>
    </MudDropContainer>
</div>

<style>
    .quad-container {
        width: 100%;
    }

    /* Layout for side-by-side display */
    .quads-section {
        flex: 4;
    }

    .unassigned-paper {
        flex: 1;
        min-width: 220px;
        max-width: 300px;
        height: fit-content;
        margin-top: 0 !important;
    }

    .quad-paper {
        width: 48%;
        margin: 0 1% 16px 1%;
        border: 1px solid #ddd;
        display: flex;
        flex-direction: column;
    }

    /* Quad table layout */
    .quad-table {
        display: flex;
        width: 100%;
        height: 100%;
        border-collapse: collapse;
    }

    .quad-side {
        width: 70px;
        /* Background color inherits from parent .quad-paper which has the color class */
        border-right: 1px solid var(--mud-palette-divider);
        display: flex;
        align-items: center;
        justify-content: center;
        writing-mode: vertical-rl;
        transform: rotate(180deg);
    }

    .quad-identifier {
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--mud-palette-text-primary);
    }

    .quad-main {
        flex: 1;
    }

    /* Quad header */
    .quad-header {
        display: flex;
        border-bottom: 1px solid var(--mud-palette-divider);
        background-color: var(--mud-palette-surface);
    }

    .quad-header-cell {
        flex: 1;
        padding: 8px;
        text-align: center;
        font-weight: bold;
        border-right: 1px solid var(--mud-palette-divider);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .player-header {
        flex: 2.45;
    }

    /* Quad dropzone */
    .quad-dropzone {
        min-height: 400px;
        background-color: var(--mud-palette-background-grey);
    }

    /* Player row in quad */
    .quad-player-row {
        display: flex;
        border-bottom: 1px solid var(--mud-palette-divider);
        background-color: var(--mud-palette-surface);
    }

    .player-cell {
        flex: 2;
        padding: 8px;
        border-right: 1px solid #ddd;
        display: flex;
        flex-direction: column;
    }

    .player-position {
        font-size: 18px;
        font-weight: bold;
        margin-right: 8px;
        color: #666;
    }

    .player-name {
        font-size: 18px;
        font-weight: bold;
        color: #666;
    }

    .player-rating {
        font-size: 16px;
        color: #333;
    }

    .round-cell {
        flex: 1;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #ddd;
        margin: 0;
    }

    .opponent {
        padding: 4px;
        text-align: center;
        border-bottom: 1px solid #eee;
        color: #666;
    }

    .score-cell {
        padding: 8px;
        text-align: center;
        font-size: 18px;
        font-weight: bold;
        background-color: inherit;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .table-number {
        padding: 4px;
        text-align: center;
        border-top: 1px solid #eee;
        color: #666;
    }

    .total-cell {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
    }

    .total-score {
        font-size: 32px;
        font-weight: bold;
        color: #666;
    }

    .remove-btn {
        position: absolute;
        top: 4px;
        right: 4px;
    }

    /* Unassigned players section */
    .unassigned-header {
        background-color: #f0f0f0;
        padding: 8px;
        border-bottom: 1px solid #ddd;
    }

    .unassigned-dropzone {
        min-height: 400px;
        padding: 8px;
        overflow-y: auto;
    }

    .player-card {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        padding: 6px;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 100%;
        font-size: 14px;
    }

    .player-number {
        font-size: 20px;
        font-weight: bold;
        margin-right: 16px;
        min-width: 24px;
        text-align: center;
    }

    .player-info {
        flex-grow: 1;
    }

    /* Pagination styles */
    .pagination-controls {
        margin-bottom: 12px;
        display: flex;
        align-items: center;
    }

    .mud-pagination {
        margin-right: 16px;
    }

    /* Theme color classes for quads */
    /* Primary color */
    .quad-paper.mud-paper.quad-color-primary {
        background-color: var(--mud-palette-primary-lighten) !important;
    }

        .quad-paper.mud-paper.quad-color-primary .quad-side {
            background-color: var(--mud-palette-primary-lighten) !important;
        }

        .quad-paper.mud-paper.quad-color-primary .score-cell {
            background-color: var(--mud-palette-primary-lighten) !important;
        }

    /* Secondary color */
    .quad-paper.mud-paper.quad-color-secondary {
        background-color: var(--mud-palette-secondary-lighten) !important;
    }

        .quad-paper.mud-paper.quad-color-secondary .quad-side {
            background-color: var(--mud-palette-secondary-lighten) !important;
        }

        .quad-paper.mud-paper.quad-color-secondary .score-cell {
            background-color: var(--mud-palette-secondary-lighten) !important;
        }

    /* Info color */
    .quad-paper.mud-paper.quad-color-info {
        background-color: var(--mud-palette-info-lighten) !important;
    }

        .quad-paper.mud-paper.quad-color-info .quad-side {
            background-color: var(--mud-palette-info-lighten) !important;
        }

        .quad-paper.mud-paper.quad-color-info .score-cell {
            background-color: var(--mud-palette-info-lighten) !important;
        }

    /* Success color */
    .quad-paper.mud-paper.quad-color-success {
        background-color: var(--mud-palette-success-lighten) !important;
    }

        .quad-paper.mud-paper.quad-color-success .quad-side {
            background-color: var(--mud-palette-success-lighten) !important;
        }

        .quad-paper.mud-paper.quad-color-success .score-cell {
            background-color: var(--mud-palette-success-lighten) !important;
        }

    /* Warning color */
    .quad-paper.mud-paper.quad-color-warning {
        background-color: var(--mud-palette-warning-lighten) !important;
    }

        .quad-paper.mud-paper.quad-color-warning .quad-side {
            background-color: var(--mud-palette-warning-lighten) !important;
        }

        .quad-paper.mud-paper.quad-color-warning .score-cell {
            background-color: var(--mud-palette-warning-lighten) !important;
        }

    /* Surface color */
    .quad-paper.mud-paper.quad-color-surface {
        background-color: var(--mud-palette-surface) !important;
    }

        .quad-paper.mud-paper.quad-color-surface .quad-side {
            background-color: var(--mud-palette-surface) !important;
        }

        .quad-paper.mud-paper.quad-color-surface .score-cell {
            background-color: var(--mud-palette-surface) !important;
        }

    /* Original colors */
    .quad-paper.mud-paper.quad-color-yellow {
        background-color: #ffffcc !important;
    }

        .quad-paper.mud-paper.quad-color-yellow .quad-side {
            background-color: #ffffcc !important;
        }

        .quad-paper.mud-paper.quad-color-yellow .score-cell {
            background-color: #ffffcc !important;
        }

    .quad-paper.mud-paper.quad-color-blue {
        background-color: #e6f7ff !important;
    }

        .quad-paper.mud-paper.quad-color-blue .quad-side {
            background-color: #e6f7ff !important;
        }

        .quad-paper.mud-paper.quad-color-blue .score-cell {
            background-color: #e6f7ff !important;
        }
</style>

<style>
    /* Media queries need to be in a separate style block in Blazor */
    @@media (max-width: 1400px) {
        .quad-paper {
            width: 31%;
        }
    }

    @@media (max-width: 1200px) {
        .quad-paper {
            width: 48%;
        }
    }

    @@media (max-width:1080px) {
        .quad-paper {
            width: 48%;
        }
    }

    @@media (max-width: 768px) {
        .d-flex {
            flex-direction: column;
        }

        .quads-section {
            width: 100%;
        }

        .unassigned-paper {
            width: 100%;
            max-width: none;
            margin-top: 16px !important;
        }

        .pagination-controls {
            flex-direction: column;
            align-items: start;
        }

            .pagination-controls .mud-pagination {
                margin-bottom: 12px;
                margin-right: 0;
            }

            .pagination-controls .mud-typography {
                margin-left: 0;
            }
    }
</style>

@code {
    [Parameter] public int TournamentId { get; set; }

    private bool IsDarkMode => ThemeProvider.IsDarkMode;
    private QuadsViewModel ViewModel { get; set; } = new();
    private string TournamentName => ViewModel?.TournamentName ?? "Tournament Name";
    public List<Quad> DisplayedQuads { get; set; } = new();
    private int CurrentPage { get; set; } = 1;
    private int TotalPages => ViewModel?.TotalPages ?? 1;
    private Dictionary<string, string> ScoreCache { get; } = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadData();
    }

    private async Task LoadData()
    {
        // Clear change tracking to avoid entity conflicts
        DbContext.ChangeTracker.Clear();

        AppState.TournamentId = TournamentId;

        var tournament = await DbContext.Tournaments
            .Include(t => t.Quads)
            .FirstOrDefaultAsync(t => t.Id == TournamentId);

        if (tournament == null)
        {
            NavigationManager.NavigateTo("/tournaments");
            return;
        }

        // Get all quads for this tournament
        var allQuads = await DbContext.Quads
            .Where(q => q.TournamentId == TournamentId)
            .OrderBy(q => q.QuadGroupNumber)
            .ToListAsync();

        // Include players in the quads - preserve manual positioning order
        foreach (var quad in allQuads)
        {
            quad.Players = await DbContext.TournamentPlayers
                .Include(tp => tp.Player)
                .Where(tp => tp.QuadId == quad.Id)
                .OrderBy(tp => tp.QuadPosition ?? 999) // Order by stored position to preserve manual arrangement
                .ToListAsync();
        }

        // Get unassigned players
        var unassignedPlayers = await DbContext.TournamentPlayers
            .Include(tp => tp.Player)
            .Where(tp => tp.TournamentId == TournamentId && !tp.QuadId.HasValue)
            .OrderByDescending(tp => tp.Player.Ranking)
            .ToListAsync();

        // Set displayed quads for current page
        var pageSize = 4;
        var skip = (CurrentPage - 1) * pageSize;
        DisplayedQuads = allQuads
            .OrderBy(q => q.QuadGroupNumber)
            .Skip(skip)
            .Take(pageSize)
            .ToList();

        // Update ViewModel
        ViewModel = new QuadsViewModel
            {
                Tournament = tournament,
                TournamentId = TournamentId,
                TournamentName = tournament.Name,
                Quads = allQuads,
                AllQuads = allQuads,
                UnassignedPlayers = unassignedPlayers.Concat(DisplayedQuads.SelectMany(q => q.Players)).ToList(),
                CurrentPage = CurrentPage,
                TotalPages = (int)Math.Ceiling(allQuads.Count / 4.0),
                AllowQuadGeneration = true,
                AllowPlayerRemoval = true,
                AllowPlayerAssignment = true,
                AreAllQuadsFull = allQuads.Count > 0 && allQuads.All(q => q.Players.Count == 4)
            };
    }

    private string GetPlayerPositionInQuad(TournamentPlayer player)
    {
        if (!player.QuadId.HasValue)
            return "";

        var quad = DisplayedQuads.FirstOrDefault(q => q.Id == player.QuadId.Value);
        if (quad == null || quad.Players.Count != 4)
            return "";

        return player.QuadPosition?.ToString() ?? "";
    }

    private string[] GetQuadOpponents(TournamentPlayer player)
    {
        if (!player.QuadId.HasValue || !player.QuadPosition.HasValue)
            return new[] { "", "", "" };

        var quad = DisplayedQuads.FirstOrDefault(q => q.Id == player.QuadId.Value);
        if (quad == null || quad.Players.Count != 4)
            return new[] { "", "", "" };

        var position = player.QuadPosition.Value;

        switch (position)
        {
            case 1: return new[] { "W v 4", "B v 3", "W v 2" };
            case 2: return new[] { "W v 3", "B v 4", "B v 1" };
            case 3: return new[] { "B v 2", "W v 1", "W v 4" };
            case 4: return new[] { "B v 1", "W v 2", "B v 3" };
            default: return new[] { "", "", "" };
        }
    }

    private int GetTableNumber(TournamentPlayer player, int round)
    {
        if (!player.QuadPosition.HasValue)
            return 1;

        var position = player.QuadPosition.Value;

        switch (position)
        {
            case 1: return round == 1 ? 1 : round == 2 ? 1 : 1;
            case 2: return round == 1 ? 2 : round == 2 ? 2 : 1;
            case 3: return round == 1 ? 2 : round == 2 ? 1 : 2;
            case 4: return round == 1 ? 1 : round == 2 ? 2 : 2;
            default: return 1;
        }
    }

    private string GetScoreKey(TournamentPlayer player, int round)
    {
        return $"{player.QuadId}-{player.Id}-{round}";
    }

    private string GetScore(TournamentPlayer player, int round)
    {
        if (!player.QuadId.HasValue)
            return "";

        var key = GetScoreKey(player, round);
        if (ScoreCache.TryGetValue(key, out var cachedScore))
            return cachedScore;

        var match = DbContext.QuadMatches
            .FirstOrDefault(m =>
                m.QuadId == player.QuadId &&
                m.RoundNumber == round &&
                (m.PlayerOneId == player.Id || m.PlayerTwoId == player.Id));

        if (match == null)
            return "";

        var score = match.PlayerOneId == player.Id
            ? match.PlayerOneScore?.ToString() ?? ""
            : match.PlayerTwoScore?.ToString() ?? "";

        ScoreCache[key] = score;
        return score;
    }

    private string GetTotalScore(TournamentPlayer player)
    {
        if (!player.QuadId.HasValue)
            return "";

        decimal total = 0;
        for (var round = 1; round <= 3; round++)
        {
            var score = GetScore(player, round);
            if (decimal.TryParse(score, out var value))
                total += value;
        }

        return total.ToString("0.#");
    }

    private async Task SaveScore(TournamentPlayer player, int round, string scoreValue)
    {
        if (!player.QuadId.HasValue)
            return;

        var key = GetScoreKey(player, round);
        ScoreCache[key] = scoreValue;
        StateHasChanged();

        try
        {
            var match = await DbContext.QuadMatches
                .FirstOrDefaultAsync(m =>
                    m.QuadId == player.QuadId &&
                    m.RoundNumber == round &&
                    (m.PlayerOneId == player.Id || m.PlayerTwoId == player.Id));

            if (match == null)
            {
                Snackbar.Add($"Match not found for Round {round}", Severity.Error);
                return;
            }

            if (match.PlayerOneId == player.Id)
            {
                match.PlayerOneScore = decimal.TryParse(scoreValue, out var score) ? score : null;
            }
            else
            {
                match.PlayerTwoScore = decimal.TryParse(scoreValue, out var score) ? score : null;
            }

            match.IsComplete = match.PlayerOneScore.HasValue && match.PlayerTwoScore.HasValue;
            if (match.IsComplete)
                match.CompletedAt = DateTime.UtcNow;

            await DbContext.SaveChangesAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving score: {ex.Message}");
            Snackbar.Add("Error saving score", Severity.Error);
            ScoreCache.Remove(key);
            StateHasChanged();
        }
    }

    
    private async Task PlayerAssigned(MudItemDropInfo<TournamentPlayer> dropInfo)
    {
        try
        {
            var playerId = dropInfo.Item.Id;
            var oldQuadId = dropInfo.Item.QuadId;

            // Get fresh entity from database to avoid tracking issues
            var dbPlayer = await DbContext.TournamentPlayers.FindAsync(playerId);
            if (dbPlayer == null) return;

            // Check if this is a reorder within the same quad
            if (dropInfo.DropzoneIdentifier != "unassigned" &&
                int.TryParse(dropInfo.DropzoneIdentifier, out var newQuadId) &&
                dbPlayer.QuadId == newQuadId)
            {
                // This is a reorder within the same quad - handle position update
                Console.WriteLine($"Detected reorder within same quad: {newQuadId}");
                await HandleQuadReordering(newQuadId, dropInfo);
                return;
            }

            // This is a move between different quads/zones
            if (dropInfo.DropzoneIdentifier == "unassigned")
            {
                dbPlayer.QuadId = null;
                dbPlayer.QuadPosition = null;
            }
            else if (int.TryParse(dropInfo.DropzoneIdentifier, out var quadId))
            {
                // Check if quad can accept another player
                var currentPlayerCount = await DbContext.TournamentPlayers
                    .CountAsync(tp => tp.QuadId == quadId);

                if (currentPlayerCount < 4 || dbPlayer.QuadId == quadId)
                {
                    dbPlayer.QuadId = quadId;
                    dbPlayer.QuadPosition = null; // Will be set in UpdateQuadAfterPlayerChange
                }
                else
                {
                    Snackbar.Add("Quad is full", Severity.Warning);
                    return;
                }
            }

            await DbContext.SaveChangesAsync();

            // Update affected quads
            if (oldQuadId.HasValue && oldQuadId != dbPlayer.QuadId)
                await UpdateQuadAfterPlayerChange(oldQuadId.Value);

            if (dbPlayer.QuadId.HasValue)
                await UpdateQuadAfterPlayerChange(dbPlayer.QuadId.Value);

            // Complete reload to ensure UI is in sync
            await LoadData();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in PlayerAssigned: {ex.Message}");
            Snackbar.Add("Error moving player", Severity.Error);
        }
    }


    private async Task HandleQuadReordering(int quadId, MudItemDropInfo<TournamentPlayer> dropInfo)
    {
        try
        {
            Console.WriteLine($"=== Handling reorder within Quad {quadId} ===");
            Console.WriteLine($"Dropped player {dropInfo.Item.Player.LastName} at index {dropInfo.IndexInZone}");

            // Clear score cache for this quad immediately
            var keysToRemove = ScoreCache.Keys.Where(k => k.StartsWith($"{quadId}-")).ToList();
            foreach (var key in keysToRemove)
            {
                ScoreCache.Remove(key);
            }

            // Get all players currently in this quad from database (in their current order)
            var currentQuadPlayers = await DbContext.TournamentPlayers
                .Include(tp => tp.Player)
                .Where(tp => tp.QuadId == quadId)
                .OrderBy(tp => tp.QuadPosition ?? 999)
                .ToListAsync();

            Console.WriteLine($"Found {currentQuadPlayers.Count} players in quad");

            // Remove the dragged player from their current position
            var draggedPlayer = currentQuadPlayers.FirstOrDefault(p => p.Id == dropInfo.Item.Id);
            if (draggedPlayer == null)
            {
                Console.WriteLine("Error: Dragged player not found in quad");
                return;
            }

            currentQuadPlayers.Remove(draggedPlayer);

            // Insert the player at the new position (IndexInZone)
            var newIndex = Math.Min(dropInfo.IndexInZone, currentQuadPlayers.Count);
            currentQuadPlayers.Insert(newIndex, draggedPlayer);

            Console.WriteLine($"Reordered players:");
            // Update all positions based on the new order
            for (int i = 0; i < currentQuadPlayers.Count; i++)
            {
                var dbPlayer = await DbContext.TournamentPlayers.FindAsync(currentQuadPlayers[i].Id);
                if (dbPlayer != null)
                {
                    var oldPosition = dbPlayer.QuadPosition;
                    dbPlayer.QuadPosition = i + 1;
                    Console.WriteLine($"  {i + 1}. {dbPlayer.Player?.LastName} (was position {oldPosition})");
                }
            }

            await DbContext.SaveChangesAsync();

            // If quad is complete (4 players), recreate matches with new positions
            if (currentQuadPlayers.Count == 4)
            {
                await UpdateQuadMatches(quadId);
            }

            // Force UI update before reload
            StateHasChanged();

            // Reload to show updated positions
            await LoadData();

            Console.WriteLine("=== Reorder complete ===");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in HandleQuadReordering: {ex.Message}");
            Snackbar.Add("Error reordering players", Severity.Error);
        }
    }
  

    

    private async Task UpdateQuadMatches(int quadId)
    {
        try
        {
            Console.WriteLine($"Updating matches for Quad {quadId}");

            // Clear score cache for this quad BEFORE deleting matches
            var keysToRemove = ScoreCache.Keys.Where(k => k.StartsWith($"{quadId}-")).ToList();
            foreach (var key in keysToRemove)
            {
                ScoreCache.Remove(key);
            }

            // Delete existing matches
            var existingMatches = await DbContext.QuadMatches
                .Where(m => m.QuadId == quadId)
                .ToListAsync();
            DbContext.QuadMatches.RemoveRange(existingMatches);

            // Get players in their new positions
            var quadPlayers = await DbContext.TournamentPlayers
                .Include(tp => tp.Player)
                .Where(tp => tp.QuadId == quadId)
                .OrderBy(tp => tp.QuadPosition)
                .ToListAsync();

            if (quadPlayers.Count == 4)
            {
                CreateMatchesForQuad(quadId, quadPlayers.ToArray());
            }

            await DbContext.SaveChangesAsync();

            // Force UI update to show cleared scores
            StateHasChanged();

            Console.WriteLine($"Matches updated and score cache cleared for Quad {quadId}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating quad matches: {ex.Message}");
            throw;
        }
    }
    
    
    
 
    private async Task RemovePlayerFromQuad(TournamentPlayer player)
    {
        try
        {
            var quadId = player.QuadId;
            if (!quadId.HasValue) return;

            // Get fresh entity from database
            var dbPlayer = await DbContext.TournamentPlayers.FindAsync(player.Id);
            if (dbPlayer == null) return;

            dbPlayer.QuadId = null;
            dbPlayer.QuadPosition = null;

            await DbContext.SaveChangesAsync();
            await UpdateQuadAfterPlayerChange(quadId.Value);
            await LoadData();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing player: {ex.Message}");
            Snackbar.Add("Error removing player", Severity.Error);
        }
    }

    // FIXED: Preserve manual player positioning within quads
    private async Task UpdateQuadAfterPlayerChange(int quadId)
    {
        using var transaction = await DbContext.Database.BeginTransactionAsync();

        try
        {
            Console.WriteLine($"=== UpdateQuadAfterPlayerChange for Quad {quadId} ===");

            // Clear score cache for this quad
            var keysToRemove = ScoreCache.Keys.Where(k => k.StartsWith($"{quadId}-")).ToList();
            foreach (var key in keysToRemove)
                ScoreCache.Remove(key);

            // Delete existing matches
            var existingMatches = await DbContext.QuadMatches
                .Where(m => m.QuadId == quadId)
                .ToListAsync();
            DbContext.QuadMatches.RemoveRange(existingMatches);

            // Get current players in quad - preserve their current order
            var quadPlayers = await DbContext.TournamentPlayers
                .Include(tp => tp.Player)
                .Where(tp => tp.QuadId == quadId)
                .OrderBy(tp => tp.QuadPosition ?? 999) // Keep existing position order
                .ToListAsync();

            Console.WriteLine($"Quad {quadId} now has {quadPlayers.Count} players");

            if (quadPlayers.Count == 4)
            {
                Console.WriteLine($"Assigning positions 1-4 to preserve manual arrangement:");
                // Assign positions 1-4 based on CURRENT order (not ranking)
                for (int i = 0; i < quadPlayers.Count; i++)
                {
                    var oldPosition = quadPlayers[i].QuadPosition;
                    quadPlayers[i].QuadPosition = i + 1;
                    Console.WriteLine($"  Player {quadPlayers[i].Player.LastName} (Ranking: {quadPlayers[i].Player.Ranking}) -> Position {oldPosition} to {i + 1}");
                }

                // Create matches
                CreateMatchesForQuad(quadId, quadPlayers.ToArray());
            }
            else
            {
                Console.WriteLine($"Clearing positions for incomplete Quad {quadId}");
                // For incomplete quads, clear positions but maintain order for when 4th player is added
                for (int i = 0; i < quadPlayers.Count; i++)
                {
                    var oldPosition = quadPlayers[i].QuadPosition;
                    quadPlayers[i].QuadPosition = i + 1; // Maintain relative positions even when incomplete
                    Console.WriteLine($"  Player {quadPlayers[i].Player.LastName} -> Position {oldPosition} to {i + 1}");
                }
            }

            await DbContext.SaveChangesAsync();
            await transaction.CommitAsync();
            Console.WriteLine($"Database changes saved successfully for Quad {quadId}");
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            Console.WriteLine($"ERROR updating quad: {ex.Message}");
            throw;
        }
    }

    private void CreateMatchesForQuad(int quadId, TournamentPlayer[] players)
    {
        // Round 1: 1v4, 2v3
        CreateMatch(quadId, players[0], players[3], 1, 1, "W");
        CreateMatch(quadId, players[1], players[2], 1, 2, "W");

        // Round 2: 1v3, 2v4
        CreateMatch(quadId, players[0], players[2], 2, 1, "B");
        CreateMatch(quadId, players[1], players[3], 2, 2, "B");

        // Round 3: 1v2, 3v4
        CreateMatch(quadId, players[0], players[1], 3, 1, "W");
        CreateMatch(quadId, players[2], players[3], 3, 2, "W");
    }

    private void CreateMatch(int quadId, TournamentPlayer player1, TournamentPlayer player2,
        int round, int table, string player1Color)
    {
        var match = new QuadMatch
            {
                QuadId = quadId,
                PlayerOneId = player1.Id,
                PlayerTwoId = player2.Id,
                RoundNumber = round,
                TableNumber = table,
                PlayerOneName = $"{player1.Player.LastName} {player1.Player.FirstName}",
                PlayerTwoName = $"{player2.Player.LastName} {player2.Player.FirstName}",
                PlayerOneRanking = player1.Player.Ranking,
                PlayerTwoRanking = player2.Player.Ranking,
                PlayerOneColor = player1Color,
                IsComplete = false
            };

        DbContext.QuadMatches.Add(match);
    }

    private async Task OnPageChanged(int page)
    {
        CurrentPage = page;
        await LoadData();
    }

    private async Task PrintPage()
    {
        await JSRuntime.InvokeVoidAsync("window.print");
    }

    // FIXED: Improved GenerateQuads with proper transaction handling
    private async Task GenerateQuads()
    {
        using var transaction = await DbContext.Database.BeginTransactionAsync();

        try
        {
            var unassignedPlayers = await DbContext.TournamentPlayers
                .Include(tp => tp.Player)
                .Where(tp => tp.TournamentId == TournamentId && !tp.QuadId.HasValue)
                .OrderByDescending(tp => tp.Player.Ranking)
                .ToListAsync();

            if (unassignedPlayers.Count == 0)
            {
                await transaction.RollbackAsync();
                return;
            }

            // Find highest quad group number
            var maxGroupQuery = await DbContext.Quads
                .Where(q => q.TournamentId == TournamentId)
                .Select(q => q.QuadGroupNumber)
                .ToListAsync();

            var highestGroupNumber = maxGroupQuery.Any() ? maxGroupQuery.Max() : 0;

            // Create quads with 4 players each
            var quadCounter = 0;
            var playerCounter = 0;
            Quad currentQuad = null;

            while (playerCounter < unassignedPlayers.Count)
            {
                // Create new quad every 4 players
                if (playerCounter % 4 == 0)
                {
                    quadCounter++;
                    currentQuad = new Quad
                        {
                            Title = $"Quad {quadCounter}",
                            TournamentId = TournamentId,
                            QuadGroupNumber = highestGroupNumber + (int)Math.Ceiling(quadCounter / 4.0)
                        };

                    DbContext.Quads.Add(currentQuad);
                    await DbContext.SaveChangesAsync(); // Save to get ID
                }

                // Assign player to quad
                var player = unassignedPlayers[playerCounter];
                player.QuadId = currentQuad.Id;
                player.QuadPosition = null; // Will be set when quad is complete

                playerCounter++;

                // When quad is full, set positions and create matches
                if (playerCounter % 4 == 0)
                {
                    var quadPlayers = unassignedPlayers
                        .Skip(playerCounter - 4)
                        .Take(4)
                        .OrderByDescending(p => p.Player.Ranking)
                        .ToArray();

                    // Set positions 1-4 based on ranking
                    for (int i = 0; i < quadPlayers.Length; i++)
                    {
                        quadPlayers[i].QuadPosition = i + 1;
                    }

                    CreateMatchesForQuad(currentQuad.Id, quadPlayers);
                }
            }

            await DbContext.SaveChangesAsync();
            await transaction.CommitAsync();

            // Reload everything
            await LoadData();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            Console.WriteLine($"Error generating quads: {ex.Message}");
            Snackbar.Add("Error generating quads", Severity.Error);
        }
    }

    private string GetThemeColorClass(int quadNumber)
    {
        switch (quadNumber % 4)
        {
            case 0: return "quad-color-primary";
            case 1: return "quad-color-success";
            case 2: return "quad-color-secondary";
            case 3: return "quad-color-info";
            default: return "quad-color-surface";
        }
    }

    private bool MatchQuadSelector(TournamentPlayer player, string identifier)
    {
        return (player.QuadId?.ToString() ?? "unassigned") == identifier;
    }
}