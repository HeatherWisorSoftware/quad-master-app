@inject TournamentContext DbContext

<div class="mb-4">
    <table class="table table-bordered">
        <tr>
            <td rowspan="13" style="width: 50px; writing-mode: vertical-lr; transform: rotate(180deg); background-color: #8bcc9c; text-align: center; font-weight: bold; font-size: 20px;">@Quad.Title</td>
            <th style="width: 5%"></th>
            <th style="width: 30%">Player</th>
            <th style="width: 15%">Rd 1</th>
            <th style="width: 15%">Rd 2</th>
            <th style="width: 15%">Rd 3</th>
            <th style="width: 10%">Total</th>
            <th style="width: 10%">Actions</th>
        </tr>
        
        @if (Quad.Players.Count == 0)
        {
            <tr>
                <td colspan="7">No players assigned to this quad yet.</td>
            </tr>
        }
        else if (Quad.Players.Count < 4)
        {
            <tr>
                <td colspan="7">A quad requires exactly 4 players. Current players: @Quad.Players.Count</td>
            </tr>
        }
        else
        {
            var orderedPlayers = Quad.Players.OrderBy(p => p.Player.Ranking).ToList();

            // Define match pairings and tables
            var matchData = new Dictionary<int, Dictionary<int, (int opponent, string color, int table, bool editable)>>
            {
                { 1, new Dictionary<int, (int, string, int, bool)> {
                    { 1, (4, "W", 1, true) },
                    { 2, (3, "W", 2, true) },
                    { 3, (2, "B", 2, true) },
                    { 4, (1, "B", 1, true) }
                }},
                { 2, new Dictionary<int, (int, string, int, bool)> {
                    { 1, (3, "B", 1, true) },
                    { 2, (4, "B", 2, true) },
                    { 3, (1, "W", 1, true) },
                    { 4, (2, "W", 2, true) }
                }},
                { 3, new Dictionary<int, (int, string, int, bool)> {
                    { 1, (2, "W", 1, true) },
                    { 2, (1, "B", 1, true) },
                    { 3, (4, "W", 2, true) },
                    { 4, (3, "B", 2, true) }
                }}
            };

            for (int playerIndex = 1; playerIndex <= Math.Min(4, orderedPlayers.Count); playerIndex++)
            {
                var player = orderedPlayers[playerIndex - 1];

                <tr>
                    <td rowspan="3" class="text-center" style="background-color: #f0f0f0;">@playerIndex</td>
                    <td style="font-weight: bold; text-align: left;">@player.Player.FirstName @player.Player.LastName</td>

                    @for (int round = 1; round <= 3; round++)
                    {
                        if (matchData.ContainsKey(playerIndex) && matchData[playerIndex].ContainsKey(round))
                        {
                            var match = matchData[playerIndex][round];
                            <td>@match.color v @match.opponent</td>
                        }
                        else
                        {
                            <td>-</td>
                        }
                    }

                    <td rowspan="3" style="font-weight: bold; font-size: 18px; text-align: center; vertical-align: middle;">
                        @GetPlayerTotal(playerIndex)
                    </td>

                    <td rowspan="3" style="text-align: center; vertical-align: middle;">
                        @if (AllowPlayerRemoval)
                        {
                            <div @onclick="() => RemovePlayer(player.Id)" style="border: 1px solid #000; border-radius: 5px; width: 25px; height: 25px; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer;">
                                X
                            </div>
                        }
                    </td>
                </tr>

                <tr>
                    <td style="text-align: left; color: #444; font-size: 14px;">
                        Rank @player.Player.Ranking
                    </td>

                    @for (int round = 1; round <= 3; round++)
                    {
                        if (matchData.ContainsKey(playerIndex) && matchData[playerIndex].ContainsKey(round))
                        {
                            var match = matchData[playerIndex][round];
                            <td style="background-color: #8bcc9c;">
                                @if (match.editable)
                                {
                                    <select class="form-select form-select-sm"
                                            style="background-color: #8bcc9c; border: none;"
                                            @onchange="(e) => UpdateScore(playerIndex, round, e.Value.ToString())">
                                        <option value="">-</option>
                                        <option value="1" selected="@(GetScore(playerIndex, round) == 1)">1</option>
                                        <option value="0" selected="@(GetScore(playerIndex, round) == 0)">0</option>
                                    </select>
                                }
                                else
                                {
                                    @GetScore(playerIndex, round)
                                }
                            </td>
                        }
                        else
                        {
                            <td style="background-color: #8bcc9c;">-</td>
                        }
                    }
                </tr>

                <tr>
                    <td></td>

                    @for (int round = 1; round <= 3; round++)
                    {
                        if (matchData.ContainsKey(playerIndex) && matchData[playerIndex].ContainsKey(round))
                        {
                            var match = matchData[playerIndex][round];
                            <td>TBL @match.table</td>
                        }
                        else
                        {
                            <td>-</td>
                        }
                    }
                </tr>
            }
        }
        }
        
        <tr>
            <td colspan="7">
                <div class="d-flex justify-content-between">
                    <span>Players: @Quad.Players.Count/4</span>
                </div>
            </td>
        </tr>
    </table>
</div>

@code {
    [Parameter]
    public Quad Quad { get; set; }

    [Parameter]
    public bool AllowPlayerRemoval { get; set; } = true;

    [Parameter]
    public EventCallback<int> OnPlayerRemoved { get; set; }

    // Store scores in a dictionary: {playerIndex: {round: score}}
    private Dictionary<int, Dictionary<int, int>> Scores { get; set; } = new Dictionary<int, Dictionary<int, int>>();

    // Match tables by round
    private Dictionary<int, Dictionary<int, int>> TableAssignments { get; set; } = new Dictionary<int, Dictionary<int, int>>
    {
        { 1, new Dictionary<int, int> { { 1, 1 }, { 2, 2 } } },
        { 2, new Dictionary<int, int> { { 1, 1 }, { 2, 2 } } },
        { 3, new Dictionary<int, int> { { 1, 1 }, { 2, 2 } } }
    };

    // Opponent pairings by round
    private Dictionary<int, Dictionary<int, int>> Pairings { get; set; } = new Dictionary<int, Dictionary<int, int>>
    {
        // Round 1: Player 1 vs 4 (Table 1), Player 2 vs 3 (Table 2)
        { 1, new Dictionary<int, int> { { 1, 4 }, { 4, 1 }, { 2, 3 }, { 3, 2 } } },
        // Round 2: Player 1 vs 3 (Table 1), Player 2 vs 4 (Table 2)
        { 2, new Dictionary<int, int> { { 1, 3 }, { 3, 1 }, { 2, 4 }, { 4, 2 } } },
        // Round 3: Player 1 vs 2 (Table 1), Player 3 vs 4 (Table 2)
        { 3, new Dictionary<int, int> { { 1, 2 }, { 2, 1 }, { 3, 4 }, { 4, 3 } } }
    };

    protected override void OnInitialized()
    {
        // Initialize scores dictionary for all player indices
        for (int i = 1; i <= 4; i++)
        {
            if (!Scores.ContainsKey(i))
            {
                Scores[i] = new Dictionary<int, int>();
            }
            
            // Set initial scores for all rounds
            for (int round = 1; round <= 3; round++)
            {
                if (!Scores[i].ContainsKey(round))
                {
                    Scores[i][round] = 0;
                }
            }
        }

        // If we have 4 players and no existing scores, set example scores as per the HTML document
        if (Quad.Players.Count == 4 && Scores.All(s => s.Value.All(r => r.Value == 0)))
        {
            // From HTML example:
            // Player 1: Wins all three rounds
            Scores[1][1] = 1;
            Scores[1][2] = 1;
            Scores[1][3] = 1;
            
            // Player 2: Wins round 2 only
            Scores[2][1] = 0;
            Scores[2][2] = 1;
            Scores[2][3] = 0;
            
            // Player 3: Wins round 1 only
            Scores[3][1] = 1;
            Scores[3][2] = 0;
            Scores[3][3] = 0;
            
            // Player 4: Wins round 3 only
            Scores[4][1] = 0;
            Scores[4][2] = 0;
            Scores[4][3] = 1;
        }
    }

    private int GetScore(int playerIndex, int round)
    {
        if (Scores.ContainsKey(playerIndex) && Scores[playerIndex].ContainsKey(round))
        {
            return Scores[playerIndex][round];
        }
        return 0;
    }

    private int GetPlayerTotal(int playerIndex)
    {
        if (!Scores.ContainsKey(playerIndex))
        {
            return 0;
        }

        return Scores[playerIndex].Values.Sum();
    }

    private void UpdateScore(int playerIndex, int round, string value)
    {
        int score;
        if (int.TryParse(value, out score) && Pairings.ContainsKey(round) && Pairings[round].ContainsKey(playerIndex))
        {
            // Get current player's opponent for this round
            int opponentIndex = Pairings[round][playerIndex];

            // Ensure dictionary entries exist
            if (!Scores.ContainsKey(playerIndex))
            {
                Scores[playerIndex] = new Dictionary<int, int>();
            }
            if (!Scores.ContainsKey(opponentIndex))
            {
                Scores[opponentIndex] = new Dictionary<int, int>();
            }
            
            if (!Scores[playerIndex].ContainsKey(round))
            {
                Scores[playerIndex][round] = 0;
            }
            if (!Scores[opponentIndex].ContainsKey(round))
            {
                Scores[opponentIndex][round] = 0;
            }

            // Update this player's score
            Scores[playerIndex][round] = score;

            // Update opponent's score (opposite of this player's score)
            Scores[opponentIndex][round] = score == 1 ? 0 : 1;

            StateHasChanged();
        }
    }

    private async Task RemovePlayer(int playerId)
    {
        if (OnPlayerRemoved.HasDelegate)
        {
            await OnPlayerRemoved.InvokeAsync(playerId);
        }
    }
}
