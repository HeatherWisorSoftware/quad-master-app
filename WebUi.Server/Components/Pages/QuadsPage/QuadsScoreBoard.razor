@inject TournamentContext DbContext

<div class="mb-4">
    <table class="table" style="border-collapse: collapse; border: 2px solid #000; width: 100%;min-width:500px; max-width: 800px;">
        <tr>
            <td rowspan="13" style="width: 50px; writing-mode: vertical-lr; transform: rotate(180deg); background-color: @TableColor; color: #000; text-align: center; font-weight: bold; font-size: 40px; border: 2px solid #000;">@Quad.Title</td>
            <th style="width: 5%; border: 2px solid #000; font-weight: bold; text-align: center"></th>
            <th style="width: 30%; border: 2px solid #000; font-weight: bold;">Player</th>
            <th style="width: 15%; border: 2px solid #000; font-weight: bold;">Rd 1</th>
            <th style="width: 15%; border: 2px solid #000; font-weight: bold;">Rd 2</th>
            <th style="width: 15%; border: 2px solid #000; font-weight: bold;">Rd 3</th>
            <th style="width: 10%; border: 2px solid #000; font-weight: bold;">Total</th>
            <th style="width: 10%; border: 2px solid #000; font-weight: bold;">Actions</th>
        </tr>

        @if (Quad.Players.Count == 0)
        {
            <tr>
                <td colspan="7" style="border: 2px solid #000; padding: 4px; text-align: center;">No players assigned to this quad yet.</td>
            </tr>
        }
        else if (Quad.Players.Count < 4)
        {
            <tr>
                <td colspan="7" style="border: 2px solid #000; padding: 4px; text-align: center;">A quad requires exactly 4 players. Current players: @Quad.Players.Count</td>
            </tr>
        }
        else
        {
            var orderedPlayers = Quad.Players.OrderBy(p => p.Player.Ranking).ToList();

            @for (int playerNum = 0; playerNum < 4; playerNum++)
            {
                int playerIndex = playerNum + 1;
                var player = orderedPlayers[playerNum];

                <tr>
                    <td rowspan="3" style="text-align: center; font-weight: bold; border: 2px solid #000;">@playerIndex</td>
                    <td style="font-weight: bold; text-align: left; border: 2px solid #000; padding: 4px;">
                        @player.Player.FirstName @player.Player.LastName
                    </td>

                    @for (int round = 1; round <= 3; round++)
                    {
                        var (opponent, color) = GetOpponentAndColor(playerIndex, round);
                        <td style="border: 2px solid #000; padding: 4px; text-align: center;">
                            @color v @opponent
                        </td>
                    }

                    <td rowspan="3" style="font-weight: bold; font-size: 18px; text-align: center; vertical-align: middle; border: 2px solid #000;">
                        @CalculateTotal(playerIndex)
                    </td>

                    <td rowspan="3" style="text-align: center; vertical-align: middle; border: 2px solid #000;">
                        @if (AllowPlayerRemoval)
                        {
                            <div @onclick="() => RemovePlayer(player.Id)" style="border: 2px solid #000; border-radius: 5px; width: 25px; height: 25px; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer;">
                                X
                            </div>
                        }
                    </td>
                </tr>

                <tr>
                    <td style="text-align: left; color: #444; font-size: 16px; border: 1px solid #000; padding: 4px;">
                        Rank @player.Player.Ranking
                    </td>


                    @for (int round = 1; round <= 3; round++)
                    {
                        int displayedRound = round;
                        int displayedPlayer = playerIndex;
                        <td style="background-color: @TableColor;font-size: 16px; border: 1px solid #000; padding: 4px; text-align: center;">
                            <select class="form-select form-select-sm"
                                    style="background-color: @TableColor; border: none; text-align: center; text-align-last: center; -moz-text-align-last: center;"
                                    @onchange="(e) => UpdateScore(displayedPlayer, displayedRound, e.Value.ToString())">
                                <option value="" selected="@(GetScore(displayedPlayer, displayedRound) == null)">-</option>
                                <option value="1" selected="@(GetScore(displayedPlayer, displayedRound) == 1)">1</option>
                                <option value="0" selected="@(GetScore(displayedPlayer, displayedRound) == 0)">0</option>
                            </select>
                        </td>
                    }
                </tr>

                <tr>
                    <td style="border: 2px solid #000; padding: 4px;"></td>

                    @for (int round = 1; round <= 3; round++)
                    {
                        int tableNumber = GetTableNumber(playerIndex, round);
                        <td style="border: 2px solid #000; padding: 4px; text-align: center;">
                            TBL @tableNumber
                        </td>
                    }
                </tr>
            }
        }

        <tr>
            <td colspan="7" style="border: 2px solid #000; padding: 4px;">
                <div class="d-flex justify-content-between">
                    <span>Players: @Quad.Players.Count/4</span>
                </div>
            </td>
        </tr>
    </table>
</div>

@code {
    [Parameter]
    public Quad Quad { get; set; }

    [Parameter]
    public bool AllowPlayerRemoval { get; set; } = true;

    [Parameter]
    public EventCallback<int> OnPlayerRemoved { get; set; }

    // Player scores: Dictionary<PlayerIndex, Dictionary<Round, Score>>
    private Dictionary<int, Dictionary<int, int?>> playerScores = new Dictionary<int, Dictionary<int, int?>>();

    // Match pairings for each round
    private Dictionary<int, Dictionary<int, (int opponent, string color, int table)>> matchPairings =
        new Dictionary<int, Dictionary<int, (int, string, int)>>
        {
        // Round 1
        { 1, new Dictionary<int, (int, string, int)>
            {
                { 1, (4, "W", 1) },
                { 2, (3, "W", 2) },
                { 3, (2, "B", 2) },
                { 4, (1, "B", 1) }
            }
        },
        // Round 2
        { 2, new Dictionary<int, (int, string, int)>
            {
                { 1, (3, "B", 1) },
                { 2, (4, "B", 2) },
                { 3, (1, "W", 1) },
                { 4, (2, "W", 2) }
            }
        },
        // Round 3
        { 3, new Dictionary<int, (int, string, int)>
            {
                { 1, (2, "W", 1) },
                { 2, (1, "B", 1) },
                { 3, (4, "W", 2) },
                { 4, (3, "B", 2) }
            }
        }
        };

    // Color palette for tables
    private List<string> ColorPalette = new List<string>
    {
        "#0A3D4F", // Deep Teal - a rich alternative to the black in the logo
        "#1C2C4C", // Navy Blue - sophisticated and elegant
        "#4A235A", // Royal Purple - adds richness with noble associations
        "#0B5345", // Forest Green - earthy and grounding
        "#D4AF37", // Gold - matches the gold accents in your logo
        "#C9AE5D", // Brass - a slightly muted gold alternative
        "#E8ECEF", // Silver Gray - for lighter elements
        "#FFF8E1"  // Cream - warm alternative to white
    };

    private Random random = new Random();
    private string TableColor { get; set; }

    protected override void OnInitialized()
    {
        // Set random table color
        int colorIndex = random.Next(ColorPalette.Count);
        TableColor = ColorPalette[colorIndex];

        // Initialize scores
        InitializeScores();
    }

    protected override void OnParametersSet()
    {
        // Re-initialize if needed
        if (playerScores.Count == 0)
        {
            InitializeScores();
        }
    }

    private void InitializeScores()
    {
        // Initialize all player scores
        for (int player = 1; player <= 4; player++)
        {
            if (!playerScores.ContainsKey(player))
            {
                playerScores[player] = new Dictionary<int, int?>();
            }

            for (int round = 1; round <= 3; round++)
            {
                if (!playerScores[player].ContainsKey(round))
                {
                    playerScores[player][round] = null;
                }
            }
        }

        // Set example scores if we have 4 players
        if (Quad.Players.Count == 4)
        {
            bool hasAnyScores = false;

            // Check if any scores are set
            foreach (var playerDict in playerScores.Values)
            {
                foreach (var score in playerDict.Values)
                {
                    if (score.HasValue && score.Value > 0)
                    {
                        hasAnyScores = true;
                        break;
                    }
                }
                if (hasAnyScores) break;
            }

            // Only set example scores if none exist
            if (!hasAnyScores)
            {
                // Example scores
                playerScores[1][1] = 1;
                playerScores[1][2] = 1;
                playerScores[1][3] = 1;

                playerScores[2][1] = 0;
                playerScores[2][2] = 1;
                playerScores[2][3] = 0;

                playerScores[3][1] = 1;
                playerScores[3][2] = 0;
                playerScores[3][3] = 0;

                playerScores[4][1] = 0;
                playerScores[4][2] = 0;
                playerScores[4][3] = 1;
            }
        }
    }

    private (int opponent, string color) GetOpponentAndColor(int playerIndex, int round)
    {
        if (matchPairings.ContainsKey(round) && matchPairings[round].ContainsKey(playerIndex))
        {
            var matchInfo = matchPairings[round][playerIndex];
            return (matchInfo.opponent, matchInfo.color);
        }
        return (0, "");
    }

    private int GetTableNumber(int playerIndex, int round)
    {
        if (matchPairings.ContainsKey(round) && matchPairings[round].ContainsKey(playerIndex))
        {
            return matchPairings[round][playerIndex].table;
        }
        return 0;
    }

    private int? GetScore(int playerIndex, int round)
    {
        if (playerScores.ContainsKey(playerIndex) && playerScores[playerIndex].ContainsKey(round))
        {
            return playerScores[playerIndex][round];
        }
        return null;
    }

    private int CalculateTotal(int playerIndex)
    {
        int total = 0;

        if (playerScores.ContainsKey(playerIndex))
        {
            for (int round = 1; round <= 3; round++)
            {
                var score = GetScore(playerIndex, round);
                if (score.HasValue && score.Value > 0)
                {
                    total += score.Value;
                }
            }
        }

        return total;
    }

    private void UpdateScore(int playerIndex, int round, string value)
    {
        // Parse score value
        int? score = null;
        if (!string.IsNullOrEmpty(value) && int.TryParse(value, out int parsedValue))
        {
            score = parsedValue;
        }

        // Get opponent
        int opponentIndex = 0;
        if (matchPairings.ContainsKey(round) && matchPairings[round].ContainsKey(playerIndex))
        {
            opponentIndex = matchPairings[round][playerIndex].opponent;
        }
        else
        {
            return; // No valid opponent found
        }

        // Ensure dictionaries exist
        if (!playerScores.ContainsKey(playerIndex))
        {
            playerScores[playerIndex] = new Dictionary<int, int?>();
        }
        if (!playerScores.ContainsKey(opponentIndex))
        {
            playerScores[opponentIndex] = new Dictionary<int, int?>();
        }

        // Make sure round entries exist
        if (!playerScores[playerIndex].ContainsKey(round))
        {
            playerScores[playerIndex][round] = null;
        }
        if (!playerScores[opponentIndex].ContainsKey(round))
        {
            playerScores[opponentIndex][round] = null;
        }

        // Set scores
        playerScores[playerIndex][round] = score;

        // Opponent gets opposite score
        if (score.HasValue)
        {
            playerScores[opponentIndex][round] = score.Value == 1 ? 0 : 1;
        }
        else
        {
            playerScores[opponentIndex][round] = null;
        }

        // Force UI refresh
        StateHasChanged();
    }

    private async Task RemovePlayer(int playerId)
    {
        if (OnPlayerRemoved.HasDelegate)
        {
            await OnPlayerRemoved.InvokeAsync(playerId);
        }
    }
}